// DebuggerCodeGui.cpp

// Copyright (C) 2012  Miroslav Sustek <sus107@vsb.cz>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// -*- C++ -*- generated by wxGlade HG on Sun Feb 19 19:08:09 2012

#include "DebuggerCodeGui.h"

// begin wxGlade: ::extracode

// end wxGlade


DebuggerCodeGui::DebuggerCodeGui(wxWindow* parent, int id, const wxPoint& pos, const wxSize& size, long style):
	wxPanel(parent, id, pos, size, wxTAB_TRAVERSAL)
{
	// begin wxGlade: DebuggerCodeGui::DebuggerCodeGui
	code_grid = new wxGrid(this, wxID_ANY);

	set_properties();
	do_layout();
	// end wxGlade

	emulator = NULL;
	debugger = NULL;

	code_grid->Connect(wxEVT_SIZE, wxSizeEventHandler(DebuggerCodeGui::OnCodeGridSize), NULL, this);

	rowContextMenu = new wxMenu();
	rowContextMenu->Append(DEBUGGER_TOGGLE_BREAKPOINT, wxT("Toggle breakpoint"), wxEmptyString, wxITEM_NORMAL);
	rowContextMenu->AppendSeparator();
	rowContextMenu->Append(DEBUGGER_SHOW_IN_HEXVIEW, wxT("Show in Hex view"), wxEmptyString, wxITEM_NORMAL);
}

DebuggerCodeGui::~DebuggerCodeGui()
{
	if (emulator) {
		emulator->removeListener(this);
	}
	if (debugger) {
		debugger->removeListener(this);
	}
}

BEGIN_EVENT_TABLE(DebuggerCodeGui, wxPanel)
	// begin wxGlade: DebuggerCodeGui::event_table
	EVT_GRID_CMD_CELL_LEFT_DCLICK(wxID_ANY, DebuggerCodeGui::OnCellLeftDClick)
	EVT_GRID_CMD_CELL_RIGHT_CLICK(wxID_ANY, DebuggerCodeGui::OnCellRightClick)
	EVT_GRID_CMD_SELECT_CELL(wxID_ANY, DebuggerCodeGui::OnSelectCell)
	EVT_GRID_CMD_CELL_CHANGE(wxID_ANY, DebuggerCodeGui::OnCellChange)
	// end wxGlade
	EVT_MENU(DEBUGGER_TOGGLE_BREAKPOINT, DebuggerCodeGui::OnContextToggleBreakpoint)
END_EVENT_TABLE();

int DebuggerCodeGui::getSelectedRow()
{
	return code_grid->GetSelectedRows().Last();
}

uint16_t DebuggerCodeGui::getSelectedStartAddress()
{
	int row = 0;
	if (code_grid->IsSelection()) {
		if (code_grid->GetSelectedRows().Count() > 0) {
			row = code_grid->GetSelectedRows().front();
		} else if (code_grid->GetSelectionBlockTopLeft().Count() > 0) {
			row = code_grid->GetSelectionBlockTopLeft().Last().GetRow();
		}
	}

	return rowToAddressMap.lower_bound(row)->second;
}

uint16_t DebuggerCodeGui::getSelectedEndAddress()
{
	int row = 0;
	if (code_grid->IsSelection()) {
		if (code_grid->GetSelectedRows().Count() > 0) {
			row = code_grid->GetSelectedRows().Last();
		} else if (code_grid->GetSelectionBlockBottomRight().Count() > 0) {
			row = code_grid->GetSelectionBlockBottomRight().Last().GetRow();
		}
	}
	return rowToAddressMap.upper_bound(row)->second - 1;
}

void DebuggerCodeGui::OnSelectCell(wxGridEvent &event)
{
	if (!event.IsSelection()) {
		// select whole row
		code_grid->SelectRow(event.GetRow());
	}
	event.Skip(); // let the cursor move
}

void DebuggerCodeGui::OnCodeSliderEndScroll(wxScrollEvent &event)
{
	uiUpdate();
}

void DebuggerCodeGui::OnCellChange(wxGridEvent &event)
{
	// make sure that CELL_CHANGE event doesn't loop,
	// because code_grid->DeleteRows() in uiUpdate() emits another CELL_CHANGE event
	if (cellChangeMutex.TryLock() == wxMUTEX_NO_ERROR) {
		if (event.GetCol() == 2) { // data
			int row = event.GetRow();
			int addr = rowToAddressMap[row];

			wxString value = code_grid->GetCellValue(row, 2);
			unsigned char data[100];
			int dataLen;
			if ((dataLen = parseHex(value, data, 100)) >= 0) {
				debugger->writeMemory(data, addr, dataLen);
			} else {
				event.Veto(); // TODO: let user fix the input
			}
		}

		// TODO: do not let cursor go to the next line
		//code_grid->SelectRow(event.GetRow(), false);
		//code_grid->SetGridCursor(0, 0);

		cellChangeMutex.Unlock();
	}
}

void DebuggerCodeGui::OnCellRightClick(wxGridEvent &event)
{
	if (code_grid->GetSelectedRows().Count() == 1 || !code_grid->IsSelection()) {
		code_grid->SelectRow(event.GetRow(), false);
	}
	PopupMenu(rowContextMenu, event.GetPosition());
}

void DebuggerCodeGui::OnCellLeftDClick(wxGridEvent &event)
{
	if (event.GetCol() == 0) { // breakpoint
		ToggleBreakpoint(event.GetRow());
	}
}

void DebuggerCodeGui::OnContextToggleBreakpoint(wxCommandEvent &event)
{
	if (code_grid->IsSelection()) {
		if (code_grid->GetSelectedRows().Count()) {
			for (int i = 0; i < code_grid->GetSelectedRows().Count(); i++) {
				ToggleBreakpoint(code_grid->GetSelectedRows().Item(i));
			}
		} else {
			int firstRow = code_grid->GetSelectionBlockTopLeft().Last().GetRow();
			int lastRow = code_grid->GetSelectionBlockBottomRight().Last().GetRow();
			for (int i = firstRow; i <= lastRow; i++) {
				ToggleBreakpoint(i);
			}
		}
	}
}

void DebuggerCodeGui::OnCodeGridSize(wxSizeEvent & event)
{
	int width = event.GetSize().GetWidth() - code_grid->GetRowLabelSize() - code_grid->GetScrollThumb(wxVERTICAL);
	code_grid->SetColumnWidth(0, 20);
	code_grid->SetColumnWidth(1, 70);
	code_grid->SetColumnWidth(2, 150);
	code_grid->SetColumnWidth(3, width - (20 + 70 + 150));
	code_grid->Refresh();
}

// wxGlade: add DebuggerCodeGui event handlers

int DebuggerCodeGui::parseHex(wxString in, unsigned char *out, int maxLen)
{
	int len = in.Length();

	unsigned char byte;
	int halfBytes = 0;
	int dataLen = 0;
	for (int i = 0; i < len; i++) {
		char c = in[i];
		if (c >= '0' && c <= '9') {
			byte = (byte << 4) | (c - '0');
		} else if (c >= 'A' && c <= 'F') {
			byte = (byte << 4) | (in[i] - 'A' + 10);
		} else if (c >= 'a' && c <= 'f') {
			byte = (byte << 4) | (in[i] - 'a' + 10);
		} else if (in[i] == ' ') {
			continue;
		} else {
			return -1;
		}
		halfBytes++;

		if (halfBytes % 2 == 0) {
			if (dataLen < maxLen) {
				out[dataLen] = byte;
				dataLen++;
			} else {
				break;
			}
		}
	}

	if (halfBytes % 2 == 0) {
		return dataLen;
	} else {
		return -1;
	}
}

void DebuggerCodeGui::ToggleBreakpoint(int row)
{
	int address = rowToAddressMap[row];

	if (!debugger->isBreakpoint(address)) {
		debugger->addBreakpoint(address);
	} else {
		debugger->removeBreakpoint(address);
	}
}

void DebuggerCodeGui::attach(Emulator *emulator, Debugger *debugger)
{
	this->emulator = emulator;
	this->debugger = debugger;
	emulator->addListener(this);
    debugger->addListener(this);

    // update UI with model data
    uiUpdate();
}

void DebuggerCodeGui::emulatorEvent(EmulatorEvent event)
{
	if (event == EMULATOR_EVENT_REGISTERS_CHANGED ||
		event == EMULATOR_EVENT_MEMORY_CHANGED ||
		event == EMULATOR_EVENT_EMULATION_START ||
		event == EMULATOR_EVENT_EMULATION_STOP ||
		event == EMULATOR_EVENT_EMULATION_STEP)
	{
		uiUpdate();
	}

	if (event == EMULATOR_EVENT_EMULATION_STOP ||
		event == EMULATOR_EVENT_EMULATION_STEP)
	{
		gotoAddress(debugger->getCpuRegister(regPC));
	}
}

void DebuggerCodeGui::debuggerEvent(DebuggerEvent event)
{
	if (event == DEBUGGER_EVENT_BREAKPOINTS_CHANGED)
	{
		uiUpdate();
	}
}

void DebuggerCodeGui::uiUpdate()
{
	if (debugger) {
		char buf[1024];
		int dummy;

		int len;
		int row = 0;

		addressToRowMap.clear();
		rowToAddressMap.clear();

		code_grid->DisableCellEditControl();
		code_grid->BeginBatch();

		for (int addr = 0; addr < 65536; addr += len) {
			addressToRowMap[addr] = row;
			rowToAddressMap[row] = addr;

			len = debugger->disassembly(buf, 1024, addr);
			if (len > 4) {
				printf("%s len = %d\n", buf, len);
			}

			if (row >= code_grid->GetRows()) {
				code_grid->InsertRows(code_grid->GetRows(), 100);
			}

			wxString imgStr;
			if ((debugger->getCpuRegister(regPC) == addr) && !emulator->isRunning()) {
				imgStr += wxT("PC");
			}
			if (debugger->isBreakpoint(addr)) {
				imgStr += wxT("BP");
			}

			code_grid->SetCellValue(row, 0, imgStr);
			code_grid->SetCellValue(row, 1, wxString::Format(wxT("%04X"), addr));

			wxString dataStr;
			for (int j = 0; j < len; j++) {
				dataStr.Append(wxString::Format(wxT("%02X"), debugger->readMemory(addr + j)));
				if (j < len - 1) {
					dataStr.Append(wxT(" "));
				}
			}
			code_grid->SetCellValue(row, 2, dataStr);

			code_grid->SetCellValue(row, 3, wxString::From8BitData(buf));

			row++;
		}

		code_grid->DeleteRows(row, code_grid->GetRows() - row);

		code_grid->EndBatch();
	}
}

void DebuggerCodeGui::gotoAddress(int address)
{
	int row = (*addressToRowMap.upper_bound(address)).second - 1;
	code_grid->SelectRow(row, false);
	code_grid->MakeCellVisible(row, 0);
}

void DebuggerCodeGui::selectAddresses(int from, int to)
{
	int firstRow = (*addressToRowMap.upper_bound(from)).second - 1;
	int lastRow = (*addressToRowMap.lower_bound(to)).second;
	code_grid->SelectBlock(firstRow, 0, lastRow, 0);
	code_grid->MakeCellVisible(firstRow, 0);
}

void DebuggerCodeGui::set_properties()
{
	// begin wxGlade: DebuggerCodeGui::set_properties
	code_grid->CreateGrid(1, 4);
	code_grid->SetRowLabelSize(0);
	code_grid->EnableGridLines(false);
	code_grid->EnableDragColSize(false);
	code_grid->EnableDragRowSize(false);
	code_grid->EnableDragGridSize(false);
	code_grid->SetSelectionMode(wxGrid::wxGridSelectRows);
	code_grid->SetColLabelValue(0, wxEmptyString);
	code_grid->SetColSize(0, 20);
	code_grid->SetColLabelValue(1, _("Address"));
	code_grid->SetColSize(1, 70);
	code_grid->SetColLabelValue(2, _("Data"));
	code_grid->SetColSize(2, 150);
	code_grid->SetColLabelValue(3, _("Instruction"));
	code_grid->SetColSize(3, 200);
	// end wxGlade

	code_grid->SetDefaultCellFont(wxFont(8, wxFONTFAMILY_TELETYPE, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL, false));
	code_grid->SetDefaultRowSize(18, true);

	for (int i = 0; i < code_grid->GetCols(); i++) {
		code_grid->SetColMinimalWidth(i, code_grid->GetColSize(i));
	}

	wxGridCellAttr *programCounterColAttr = code_grid->GetOrCreateCellAttr(0, 0);
	wxGridCellAttr *addressColAttr = code_grid->GetOrCreateCellAttr(0, 1);
	wxGridCellAttr *dataColAttr = code_grid->GetOrCreateCellAttr(0, 2);
	wxGridCellAttr *codeColAttr = code_grid->GetOrCreateCellAttr(0, 3);

	programCounterColAttr->SetReadOnly(true);
	programCounterColAttr->SetRenderer(new GridCellBitmapRenderer());
	addressColAttr->SetReadOnly(true);
	codeColAttr->SetReadOnly(true);

	code_grid->SetColAttr(0, programCounterColAttr);
	code_grid->SetColAttr(1, addressColAttr);
	code_grid->SetColAttr(2, dataColAttr);
	code_grid->SetColAttr(3, codeColAttr);

	code_grid->SetCellHighlightPenWidth(1);
	code_grid->SetCellHighlightROPenWidth(1);

	code_grid->SetScrollLineX(1);
	code_grid->SetScrollLineY(code_grid->GetRowHeight(0));

	code_grid->SetMargins(0 - wxSYS_VSCROLL_X, 0);
}


void DebuggerCodeGui::do_layout()
{
	// begin wxGlade: DebuggerCodeGui::do_layout
	wxBoxSizer* code_sizer = new wxBoxSizer(wxHORIZONTAL);
	code_sizer->Add(code_grid, 1, wxEXPAND, 0);
	SetSizer(code_sizer);
	code_sizer->Fit(this);
	// end wxGlade
}

