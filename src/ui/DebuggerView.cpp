// DebuggerView.cpp

// Copyright (C) 2012  Miroslav Sustek <sus107@vsb.cz>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// -*- C++ -*- generated by wxGlade HG on Fri Feb  3 02:55:31 2012

#include "DebuggerView.h"

// begin wxGlade: ::extracode

// end wxGlade


DebuggerView::DebuggerView(wxWindow* parent, int id, const wxString& title, const wxPoint& pos, const wxSize& size, long style):
	wxFrame(parent, id, title, pos, size, wxDEFAULT_FRAME_STYLE)
{
	// begin wxGlade: DebuggerView::DebuggerView
	notebook = new wxNotebook(this, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
	notebook_pane_hex = new wxPanel(notebook, wxID_ANY);
	debugger_menubar = new wxMenuBar();
	wxMenu* wxglade_tmp_menu_1 = new wxMenu();
	wxglade_tmp_menu_1->Append(DEBUGGER_EDIT_GOTO, _("Go to address..."), _("Add or remove breakpoint at selected address"), wxITEM_NORMAL);
	debugger_menubar->Append(wxglade_tmp_menu_1, _("Edit"));
	wxMenu* wxglade_tmp_menu_2 = new wxMenu();
	wxglade_tmp_menu_2->Append(DEBUGGER_VIEW_REGISTERS, _("Registers..."), wxEmptyString, wxITEM_NORMAL);
	debugger_menubar->Append(wxglade_tmp_menu_2, _("View"));
	wxMenu* wxglade_tmp_menu_3 = new wxMenu();
	wxglade_tmp_menu_3->Append(DEBUGGER_TOOL_CONTINUE, _("Continue"), wxEmptyString, wxITEM_NORMAL);
	wxglade_tmp_menu_3->Append(DEBUGGER_TOOL_BREAK, _("Break"), wxEmptyString, wxITEM_NORMAL);
	wxglade_tmp_menu_3->Append(DEBUGGER_TOOL_STEP, _("Step instruction"), wxEmptyString, wxITEM_NORMAL);
	debugger_menubar->Append(wxglade_tmp_menu_3, _("Debugger"));
	SetMenuBar(debugger_menubar);
	debugger_view_toolbar = new wxToolBar(this, -1);
	SetToolBar(debugger_view_toolbar);
	debugger_view_toolbar->SetToolBitmapSize(wxSize(24, 24));
	debugger_view_toolbar->AddTool(DEBUGGER_TOOL_CONTINUE, _("Continue"), (*_img_media_playback_start_4), wxNullBitmap, wxITEM_NORMAL, _("Continue program execution"), wxEmptyString);
	debugger_view_toolbar->AddTool(DEBUGGER_TOOL_BREAK, _("Break"), (*_img_media_playback_pause_4), wxNullBitmap, wxITEM_NORMAL, _("Break program"), wxEmptyString);
	debugger_view_toolbar->AddTool(DEBUGGER_TOOL_STEP, _("Step"), (*_img_debug_step_into_instruction), wxNullBitmap, wxITEM_NORMAL, _("Step instruction"), wxEmptyString);
	debugger_view_toolbar->AddSeparator();
	debugger_view_toolbar->AddTool(DEBUGGER_TOOL_GOTOPC, _("Go to PC"), (*_img_go_next_4), wxNullBitmap, wxITEM_NORMAL, _("Go to Program Counter"), wxEmptyString);
	debugger_view_toolbar->Realize();
	debugger_code_view = new DebuggerCodeGui(notebook, wxID_ANY);
	hex_view = new DebuggerHexGui(notebook_pane_hex, wxID_ANY);

	set_properties();
	do_layout();
	// end wxGlade

	emulator = NULL;
	debugger = NULL;
}

DebuggerView::~DebuggerView()
{
	if (emulator) {
		emulator->removeListener(this);
	}
	if (debugger) {
		debugger->removeListener(this);
	}
}

void DebuggerView::emulatorEvent(EmulatorEvent event)
{
	if (event == EMULATOR_EVENT_EMULATION_START ||
		event == EMULATOR_EVENT_EMULATION_STOP ||
		event == EMULATOR_EVENT_EMULATION_STEP)
	{
		uiUpdate();
	}
}

void DebuggerView::debuggerEvent(DebuggerEvent event)
{
	// nothing ?
}

void DebuggerView::attach(Emulator *emulator, Debugger *debugger)
{
    this->emulator = emulator;
    this->debugger = debugger;
    debugger_code_view->attach(emulator, debugger);
    hex_view->attach(emulator, debugger);

    emulator->addListener(this);
    debugger->addListener(this);
}

BEGIN_EVENT_TABLE(DebuggerView, wxFrame)
	// begin wxGlade: DebuggerView::event_table
	EVT_MENU(DEBUGGER_EDIT_GOTO, DebuggerView::OnEditGotoAddress)
	EVT_MENU(DEBUGGER_VIEW_REGISTERS, DebuggerView::OnViewRegisters)
	EVT_TOOL(DEBUGGER_TOOL_CONTINUE, DebuggerView::OnDebuggerContinue)
	EVT_TOOL(DEBUGGER_TOOL_BREAK, DebuggerView::OnDebuggerBreak)
	EVT_TOOL(DEBUGGER_TOOL_STEP, DebuggerView::OnDebuggerStep)
	EVT_TOOL(DEBUGGER_TOOL_GOTOPC, DebuggerView::OnDebuggerGotoPc)
	EVT_NOTEBOOK_PAGE_CHANGED(wxID_ANY, DebuggerView::OnDebuggerNotebookPageChanged)
	// end wxGlade
	EVT_MENU(DEBUGGER_SHOW_IN_HEXVIEW, DebuggerView::OnShowInHexView)
	EVT_MENU(DEBUGGER_SHOW_IN_CODEVIEW, DebuggerView::OnShowInCodeView)
END_EVENT_TABLE();

void DebuggerView::uiUpdate()
{
	if (debugger->getEmulator()->isRunning()) {
		GetMenuBar()->Enable(DEBUGGER_TOOL_CONTINUE, false);
		GetMenuBar()->Enable(DEBUGGER_TOOL_BREAK, true);
		GetMenuBar()->Enable(DEBUGGER_TOOL_STEP, false);

		GetToolBar()->EnableTool(DEBUGGER_TOOL_CONTINUE, false);
		GetToolBar()->EnableTool(DEBUGGER_TOOL_BREAK, true);
		GetToolBar()->EnableTool(DEBUGGER_TOOL_STEP, false);
	} else {
		GetMenuBar()->Enable(DEBUGGER_TOOL_CONTINUE, true);
		GetMenuBar()->Enable(DEBUGGER_TOOL_BREAK, false);
		GetMenuBar()->Enable(DEBUGGER_TOOL_STEP, true);

		GetToolBar()->EnableTool(DEBUGGER_TOOL_CONTINUE, true);
		GetToolBar()->EnableTool(DEBUGGER_TOOL_BREAK, false);
		GetToolBar()->EnableTool(DEBUGGER_TOOL_STEP, true);
	}
}

void DebuggerView::OnDebuggerStep(wxCommandEvent &event)
{
	debugger->stepInstruction();
}

void DebuggerView::OnDebuggerContinue(wxCommandEvent &event)
{
	debugger->emulationContinue();
}

void DebuggerView::OnDebuggerBreak(wxCommandEvent &event)
{
	debugger->emulationBreak();
}

void DebuggerView::OnDebuggerGotoPc(wxCommandEvent & event)
{
	debugger_code_view->gotoAddress(debugger->getCpuRegister(regPC));
}

void DebuggerView::OnEditGotoAddress(wxCommandEvent & event)
{
	wxTextEntryDialog *dialog = new wxTextEntryDialog(this, _("Address (hex):"), _("Go to address..."));

	if (dialog->ShowModal() == wxID_OK) {
		unsigned long int val;
		if (dialog->GetValue().ToULong(&val, 16)) {
			debugger_code_view->gotoAddress(val);
			hex_view->Select(val, val);
			hex_view->MakeAddressVisible(val);
		}
	}
}

void DebuggerView::OnViewRegisters(wxCommandEvent &event)
{
	DebuggerRegistersView *registersView = new DebuggerRegistersView(this, wxID_ANY, wxEmptyString);
	registersView->attach(emulator, debugger);
	registersView->Show(true);
	registersView->uiUpdate();
	debugger->addListener(registersView);
}

void DebuggerView::OnDebuggerNotebookPageChanged(wxNotebookEvent & event)
{
	if (event.GetSelection() == 0) {
		debugger_code_view->uiUpdate();
	}
}

void DebuggerView::OnShowInHexView(wxCommandEvent & event)
{
	hex_view->Select(debugger_code_view->getSelectedStartAddress(), debugger_code_view->getSelectedEndAddress());
	hex_view->MakeAddressVisible(debugger_code_view->getSelectedStartAddress());
	notebook->ChangeSelection(1);
}

void DebuggerView::OnShowInCodeView(wxCommandEvent & event)
{
	if (hex_view->select->GetState()) {
		debugger_code_view->selectAddresses(hex_view->select->StartOffset, hex_view->select->EndOffset);
	} else {
		debugger_code_view->gotoAddress(hex_view->CursorOffset());
	}
	hex_view->MakeAddressVisible(debugger_code_view->getSelectedStartAddress());
	notebook->ChangeSelection(0);
}

// wxGlade: add DebuggerView event handlers


void DebuggerView::set_properties()
{
	// begin wxGlade: DebuggerView::set_properties
	SetTitle(_("Debugger"));
	SetSize(wxSize(430, 480));
	// end wxGlade
}

void DebuggerView::do_layout()
{
	// begin wxGlade: DebuggerView::do_layout
	wxBoxSizer* debugger_panes = new wxBoxSizer(wxVERTICAL);
	wxBoxSizer* sizer_1 = new wxBoxSizer(wxHORIZONTAL);
	sizer_1->Add(hex_view, 1, wxEXPAND, 0);
	notebook_pane_hex->SetSizer(sizer_1);
	notebook->AddPage(debugger_code_view, _("Code view"));
	notebook->AddPage(notebook_pane_hex, _("Hex view"));
	debugger_panes->Add(notebook, 1, wxEXPAND, 0);
	SetSizer(debugger_panes);
	Layout();
	// end wxGlade
}

